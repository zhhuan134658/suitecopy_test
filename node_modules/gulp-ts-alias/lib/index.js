"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const o_stream_1 = __importDefault(require("o-stream"));
const COMMENTED_PATTERN = /(\/\*(?:(?!\*\/).|[\n\r])*\*\/)|(\/\/[^\n\r]*(?:[\n\r]+|$))/;
const IMPORT_PATTERNS = [/from (["'])(.*?)\1/, /import\((["'])(.*?)\1\)/, /require\((["'])(.*?)\1\)/];
function parseImports(file, dir) {
    return file
        .map((line, index) => findImports(line)
        .map((i) => ({ path: dir, index, import: i })))
        .reduce((acc, val) => acc.concat(val), []);
}
function findImports(line) {
    if (line.match(COMMENTED_PATTERN)) {
        return [];
    }
    return IMPORT_PATTERNS
        .map((pattern) => line.match(RegExp(pattern, 'g')))
        .reduce((acc, val) => acc.concat(val), [])
        .filter((value) => value !== null)
        .map((match) => IMPORT_PATTERNS.reduce((matched, pattern) => matched || match.match(pattern), null)[2]);
}
function resolveImports(file, imports, options) {
    const { baseUrl, paths, cwd } = options;
    const aliases = {};
    for (const alias in paths) {
        /* istanbul ignore else  */
        if (paths.hasOwnProperty(alias)) {
            let resolved = alias;
            if (alias.endsWith('/*')) {
                resolved = alias.replace('/*', '/');
            }
            aliases[resolved] = paths[alias];
        }
    }
    const lines = [...file];
    for (const imported of imports) {
        const line = file[imported.index];
        let resolved = '';
        for (const alias in aliases) {
            /* istanbul ignore else  */
            if (aliases.hasOwnProperty(alias) && imported.import.startsWith(alias)) {
                const choices = aliases[alias];
                if (choices !== undefined) {
                    resolved = choices[0];
                    if (resolved.endsWith('/*')) {
                        resolved = resolved.replace('/*', '/');
                    }
                    resolved = imported.import.replace(alias, resolved);
                    break;
                }
            }
        }
        if (resolved.length < 1) {
            continue;
        }
        const dirname = path_1.default.dirname(imported.path);
        let relative = path_1.default.join(path_1.default.resolve(baseUrl || './'), cwd);
        relative = path_1.default.relative(dirname, relative);
        relative = path_1.default.join(relative, resolved);
        relative = path_1.default.relative(dirname, path_1.default.join(dirname, relative));
        relative = relative.replace(/\\/g, '/');
        if (relative.length === 0 || !relative.startsWith('.')) {
            relative = './' + relative;
        }
        lines[imported.index] = line.replace(imported.import, relative);
    }
    return lines;
}
const aliasPlugin = (pluginOptions) => {
    if (pluginOptions.configuration === undefined || pluginOptions.configuration === null) {
        // tslint:disable-next-line:max-line-length
        throw new Error('The \"configuration\" option cannot be empty. Provide the tsconfig or compilerOptions object.');
    }
    // tslint:disable-next-line:max-line-length
    const compilerOptions = pluginOptions.configuration.compilerOptions || pluginOptions.configuration;
    if (compilerOptions.paths === undefined || compilerOptions.paths === null) {
        throw new Error('Unable to find the \"paths\" property in the supplied configuration!');
    }
    if (compilerOptions.baseUrl === undefined || compilerOptions.baseUrl === '.') {
        compilerOptions.baseUrl = './';
    }
    if (pluginOptions.cwd === undefined || pluginOptions.cwd === '.') {
        compilerOptions.cwd = './';
    }
    else {
        compilerOptions.cwd = pluginOptions.cwd;
    }
    return o_stream_1.default.transform({
        onEntered: (args) => {
            const file = args.object;
            /* istanbul ignore if */
            if (file.isStream()) {
                throw new Error('Streaming is not supported.');
            }
            if (file.isNull() || !file.contents) {
                args.output.push(file);
                return;
            }
            if (!file.path) {
                throw new Error('Received file with no path. Files must have path to be resolved.');
            }
            const lines = file.contents.toString().split('\n');
            const imports = parseImports(lines, file.path);
            if (imports.length === 0) {
                args.output.push(file);
                return;
            }
            const resolved = resolveImports(lines, imports, compilerOptions);
            file.contents = Buffer.from(resolved.join('\n'));
            args.output.push(file);
        },
    });
};
exports.default = aliasPlugin;
// ES5/ES6 fallbacks
module.exports = aliasPlugin;
module.exports.default = aliasPlugin;
//# sourceMappingURL=index.js.map